import os
import socket
import threading
from dotenv import load_dotenv
from datetime import datetime


# ==========================================
# CONFIGURACIÓN DEL ESCANEO
# ==========================================
# Objetivo a escanear (IP o dominio)
sTarget = "127.0.0.1"  # Mi equipo: "127.0.0.1", Mi Router: "192.168.1.1", "google.com", "scanme.nmap.org"

# Rango de puertos a escanear
iStartPort = 1
iEndPort = 5000 #1024

# Tiempo máximo de espera por puerto (en segundos)
fTimeout = 1.0

# Mostrar solo puertos abiertos (True = sí, False = mostrar todo)
bShowOnlyOpen = True

# Cargar el archivo .env
load_dotenv()
# Obtener la ruta desde el archivo .env
# Ruta del archivo donde se guardarán los resultados
sOUTPUT_FILE = os.getenv('OUTPUT_FILE')

# Diccionario con algunos servicios comunes y sus puertos
dCommonPorts = {
   20: "FTP Data",
   21: "FTP",
   22: "SSH",
   23: "Telnet",
   25: "SMTP",
   53: "DNS",
   80: "HTTP",
   110: "POP3",
   143: "IMAP",
   443: "HTTPS",
   3306: "MySQL",
   3389: "RDP",
   8080: "HTTP-alt"
}


# ==========================================
# FUNCIONES DEL ESCÁNER
# ==========================================
# Usamos una lista global para almacenar resultados
lResults = []

# Lock para evitar que múltiples hilos impriman al mismo tiempo
print_lock = threading.Lock()

# Función que escanea un solo puerto
def fScanPort(iPort):
   try:
      # Crear socket TCP
      oSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
      oSocket.settimeout(fTimeout)

      # Intentar conectarse al puerto
      iResult = oSocket.connect_ex((sTarget, iPort))

      # Si la conexión fue exitosa (puerto abierto)
      if iResult == 0:
         try:
            # Intentar recibir información (banner del servicio)
            sBanner = oSocket.recv(1024).decode(errors="ignore").strip()
         except:
            sBanner = "N/A"

         # Obtener nombre del servicio si es conocido
         sService = dCommonPorts.get(iPort, "Desconocido")

         # Formar línea de resultado
         sResult = f"INFO    - [+] Puerto {iPort} ABIERTO ({sService}) | Banner: {sBanner}"

         # Imprimir y guardar el resultado (con control de concurrencia)
         with print_lock:
            print(sResult)
            lResults.append(sResult)
      elif not bShowOnlyOpen:
         # Mostrar también puertos cerrados si se configuró así
         sResult = f"INFO    - [-] Puerto {iPort} cerrado"
         with print_lock:
            print(sResult)

      # Cerrar socket
      oSocket.close()
   except Exception as e:
      # Manejo de errores por puerto
      with print_lock:
         print(f"ERROR   - Error escaneando puerto {iPort}: {e}")


# ==========================================
# INICIO DEL ESCANEO
# ==========================================
print(f"\nINFO    - Iniciando escaneo de {sTarget} (puertos {iStartPort}-{iEndPort})")
dtInicio = datetime.now()
print(f"INFO    - Inicio: {dtInicio.strftime('%Y-%m-%d %H:%M:%S')}\n")

# Crear hilos para cada puerto
lThreads = []
for iPuerto in range(iStartPort, iEndPort + 1):
   t = threading.Thread(target=fScanPort, args=(iPuerto,))
   lThreads.append(t)
   t.start()

# Esperar a que todos los hilos terminen
for t in lThreads:
   t.join()

# Fin del escaneo
dtFin = datetime.now()
tdDuracion = dtFin - dtInicio

print(f"\nINFO    - Escaneo finalizado: {dtFin.strftime('%Y-%m-%d %H:%M:%S')}")
print(f"INFO    - Duración total: {tdDuracion}")


# ==========================================
# GUARDAR RESULTADOS A ARCHIVO
# ==========================================
try:
   with open(sOUTPUT_FILE, "w") as fOut:
      fOut.write(f"Escaneo de {sTarget}\n")
      fOut.write(f"Inicio: {dtInicio}\nFin: {dtFin}\nDuración: {tdDuracion}\n\n")
      for sLinea in lResults:
         fOut.write(sLinea + "\n")
   print(f"\nINFO    - Resultados guardados en: {sOUTPUT_FILE}")
except Exception as e:
   print(f"ERROR   - No se pudo guardar el archivo: {e}")
